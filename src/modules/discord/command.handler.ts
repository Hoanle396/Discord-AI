import { Injectable, Logger } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { Message } from 'discord.js';
import { ConfigService } from '@nestjs/config';
import { User } from '../health/entities/user.entity';
import { HealthRecord, HealthRecordType } from '../health/entities/health-record.entity';
import { Reminder, ReminderType } from '../health/entities/reminder.entity';
import { EmergencyContact } from '../health/entities/emergency-contact.entity';
import { GeminiService } from '../gemini/gemini.service';

@Injectable()
export class CommandHandler {
  private readonly logger = new Logger(CommandHandler.name);

  constructor(
    private configService: ConfigService,
    private geminiService: GeminiService,
    @InjectRepository(User)
    private userRepository: Repository<User>,
    @InjectRepository(HealthRecord)
    private healthRecordRepository: Repository<HealthRecord>,
    @InjectRepository(Reminder)
    private reminderRepository: Repository<Reminder>,
    @InjectRepository(EmergencyContact)
    private emergencyContactRepository: Repository<EmergencyContact>,
  ) {}

  async handleCommand(message: Message) {
    const prefix = this.configService.get('BOT_PREFIX', '!');
    const args = message.content.slice(prefix.length).trim().split(/ +/);
    const command = args.shift()?.toLowerCase();

    // Ensure user exists
    const user = await this.ensureUserExists(message.author.id, message.author.username);

    try {
      switch (command) {
        case 'ping':
          await message.reply('Pong! üèì Bot ƒëang ho·∫°t ƒë·ªông t·ªët!');
          break;
        case 'health':
        case 'suckhoe':
          await this.handleHealthCommand(message, args, user);
          break;
        case 'reminder':
        case 'nhacnho':
          await this.handleReminderCommand(message, args, user);
          break;
        case 'emergency':
        case 'khancap':
          await this.handleEmergencyCommand(message, args, user);
          break;
        case 'stats':
        case 'thongke':
          await this.handleStatsCommand(message, user);
          break;
        case 'help':
        case 'trogiup':
          await this.sendHelpMessage(message);
          break;
        default:
          await message.reply('L·ªánh kh√¥ng h·ª£p l·ªá. G√µ `!help` ho·∫∑c `!trogiup` ƒë·ªÉ xem c√°c l·ªánh c√≥ s·∫µn.');
      }
    } catch (error) {
      this.logger.error('Error handling command:', error);
      await message.reply('Xin l·ªói, ƒë√£ x·∫£y ra l·ªói khi x·ª≠ l√Ω l·ªánh c·ªßa b·∫°n. Vui l√≤ng th·ª≠ l·∫°i.');
    }
  }

  async handleMention(message: Message) {
    try {
      // Show typing indicator

      const user = await this.ensureUserExists(message.author.id, message.author.username);
      
      // Add health context for AI
      const healthContext = `Ng∆∞·ªùi d√πng: ${user.username}\n`;
      const cleanMessage = message.content.replace(/<@!?\d+>/g, '').trim();
      const prompt = `${healthContext}Ng·ªØ c·∫£nh Bot S·ª©c kh·ªèe: B·∫°n l√† m·ªôt tr·ª£ l√Ω chƒÉm s√≥c s·ª©c kh·ªèe h·ªØu √≠ch. Tr·∫£ l·ªùi c√°c c√¢u h·ªèi li√™n quan ƒë·∫øn s·ª©c kh·ªèe, ƒë∆∞a ra l·ªùi khuy√™n v·ªÅ chƒÉm s√≥c s·ª©c kh·ªèe t·ªïng qu√°t, v√† gi√∫p theo d√µi s·ª©c kh·ªèe. Lu√¥n nh·∫Øc nh·ªü ng∆∞·ªùi d√πng tham kh·∫£o √Ω ki·∫øn c·ªßa c√°c chuy√™n gia y t·∫ø cho nh·ªØng v·∫•n ƒë·ªÅ nghi√™m tr·ªçng. Tr·∫£ l·ªùi b·∫±ng ti·∫øng Vi·ªát.\n\nTin nh·∫Øn c·ªßa ng∆∞·ªùi d√πng: ${cleanMessage}`;

      const response = await this.geminiService.generateResponse(prompt);
      
      // Split long responses if needed
      if (response.length > 2000) {
        const chunks = this.splitMessage(response, 2000);
        for (const chunk of chunks) {
          await message.reply(chunk);
        }
      } else {
        await message.reply(response);
      }
    } catch (error) {
      this.logger.error('Error in AI chat:', error);
      await message.reply('Xin l·ªói, t√¥i g·∫∑p kh√≥ khƒÉn khi x·ª≠ l√Ω tin nh·∫Øn c·ªßa b·∫°n. Vui l√≤ng th·ª≠ l·∫°i ho·∫∑c s·ª≠ d·ª•ng c√°c l·ªánh c·ª• th·ªÉ.');
    }
  }

  private async ensureUserExists(discordId: string, username: string): Promise<User> {
    let user = await this.userRepository.findOne({ where: { discordId } });
    
    if (!user) {
      user = this.userRepository.create({
        discordId,
        username,
      });
      await this.userRepository.save(user);
      this.logger.log(`Created new user: ${username} (${discordId})`);
    }
    
    return user;
  }

  private splitMessage(text: string, maxLength: number): string[] {
    const chunks = [];
    let currentChunk = '';

    const sentences = text.split('. ');
    for (const sentence of sentences) {
      if ((currentChunk + sentence + '. ').length > maxLength) {
        if (currentChunk) {
          chunks.push(currentChunk.trim());
          currentChunk = '';
        }
      }
      currentChunk += sentence + '. ';
    }

    if (currentChunk) {
      chunks.push(currentChunk.trim());
    }

    return chunks;
  }

  private async handleHealthCommand(message: Message, args: string[], user: User) {
    const subCommand = args[0]?.toLowerCase();

    switch (subCommand) {
      case 'record':
      case 'ghi':
        await this.recordHealthData(message, args.slice(1), user);
        break;
      case 'history':
      case 'lichsu':
        await this.showHealthHistory(message, user);
        break;
      case 'bmi':
        await this.calculateBMI(message, args.slice(1), user);
        break;
      default:
        await message.reply('üè• **L·ªánh S·ª©c kh·ªèe**\n`!health ghi <lo·∫°i> <gi√° tr·ªã> <ghi ch√∫>` - Ghi l·∫°i d·ªØ li·ªáu s·ª©c kh·ªèe\n`!health lichsu` - Xem l·ªãch s·ª≠ s·ª©c kh·ªèe\n`!health bmi <chi·ªÅu cao> <c√¢n n·∫∑ng>` - T√≠nh ch·ªâ s·ªë BMI');
    }
  }

  private async recordHealthData(message: Message, args: string[], user: User) {
    if (args.length < 2) {
      await message.reply('üìù **Ghi l·∫°i D·ªØ li·ªáu S·ª©c kh·ªèe**\nC√°ch d√πng: `!health ghi <lo·∫°i> <gi√° tr·ªã> [ghi ch√∫]`\nC√°c lo·∫°i: cannang, huyetap, nhiptim, duonghuyet, nhietdo, thuoc\nV√≠ d·ª•: `!health ghi cannang 70kg C·∫£m th·∫•y kh·ªèe m·∫°nh h√¥m nay`');
      return;
    }

    const type = args[0].toLowerCase();
    const value = args[1];
    const notes = args.slice(2).join(' ') || '';

    const validTypes = ['cannang', 'huyetap', 'nhiptim', 'duonghuyet', 'nhietdo', 'thuoc', 'tapthe', 'ngu'];
    const typeMap = {
      'cannang': 'weight',
      'huyetap': 'blood_pressure', 
      'nhiptim': 'heart_rate',
      'duonghuyet': 'glucose',
      'nhietdo': 'temperature',
      'thuoc': 'medication',
      'tapthe': 'exercise',
      'ngu': 'sleep'
    };
    
    if (!validTypes.includes(type)) {
      await message.reply(`‚ùå Lo·∫°i kh√¥ng h·ª£p l·ªá. C√°c lo·∫°i h·ª£p l·ªá: ${validTypes.join(', ')}`);
      return;
    }

    try {
      const healthRecord = this.healthRecordRepository.create({
        user,
        type: typeMap[type] as any,
        data: value,
        notes,
        recordedAt: new Date(),
      });

      await this.healthRecordRepository.save(healthRecord);
      
      // Generate AI advice
      const aiAdvice = await this.geminiService.generateHealthAdvice({
        type: typeMap[type],
        value,
        notes,
      });

      await message.reply(`‚úÖ **ƒê√£ L∆∞u D·ªØ li·ªáu S·ª©c kh·ªèe**\nüìä Lo·∫°i: ${type}\nüìà Gi√° tr·ªã: ${value}\nüìù Ghi ch√∫: ${notes || 'Kh√¥ng c√≥'}\nüïê Th·ªùi gian: ${new Date().toLocaleString('vi-VN')}\n\nü§ñ **L·ªùi khuy√™n AI**: ${aiAdvice}`);
    } catch (error) {
      this.logger.error('Error saving health record:', error);
      await message.reply('‚ùå Kh√¥ng th·ªÉ l∆∞u d·ªØ li·ªáu s·ª©c kh·ªèe. Vui l√≤ng th·ª≠ l·∫°i.');
    }
  }

  private async showHealthHistory(message: Message, user: User) {
    try {
      const records = await this.healthRecordRepository.find({
        where: { user: { id: user.id } },
        order: { recordedAt: 'DESC' },
        take: 10,
      });

      if (records.length === 0) {
        await message.reply('üìä **L·ªãch s·ª≠ S·ª©c kh·ªèe**\nKh√¥ng t√¨m th·∫•y d·ªØ li·ªáu s·ª©c kh·ªèe n√†o. B·∫Øt ƒë·∫ßu ghi l·∫°i v·ªõi `!health ghi`');
        return;
      }

      const historyEmbed = {
        color: 0x00ff00,
        title: 'üìä L·ªãch s·ª≠ S·ª©c kh·ªèe G·∫ßn ƒë√¢y c·ªßa B·∫°n',
        fields: records.map((record, index) => ({
          name: `${index + 1}. ${record.type.toUpperCase()}`,
          value: `üìà **Gi√° tr·ªã:** ${record.data}\nüìù **Ghi ch√∫:** ${record.notes || 'Kh√¥ng c√≥'}\nüïê **Ng√†y:** ${new Date(record.recordedAt).toLocaleDateString('vi-VN')}`,
          inline: true,
        })),
        timestamp: new Date().toISOString(),
      };

      await message.reply({ embeds: [historyEmbed] });
    } catch (error) {
      this.logger.error('Error fetching health history:', error);
      await message.reply('‚ùå Kh√¥ng th·ªÉ l·∫•y l·ªãch s·ª≠ s·ª©c kh·ªèe. Vui l√≤ng th·ª≠ l·∫°i.');
    }
  }

  private async calculateBMI(message: Message, args: string[], user: User) {
    if (args.length < 2) {
      await message.reply('üìè **M√°y t√≠nh BMI**\nC√°ch d√πng: `!health bmi <chi·ªÅu_cao_cm> <c√¢n_n·∫∑ng_kg>`\nV√≠ d·ª•: `!health bmi 175 70`');
      return;
    }

    const height = parseFloat(args[0]);
    const weight = parseFloat(args[1]);

    if (isNaN(height) || isNaN(weight) || height <= 0 || weight <= 0) {
      await message.reply('‚ùå Vui l√≤ng cung c·∫•p chi·ªÅu cao (cm) v√† c√¢n n·∫∑ng (kg) h·ª£p l·ªá.');
      return;
    }

    const heightInMeters = height / 100;
    const bmi = weight / (heightInMeters * heightInMeters);
    
    let category = '';
    let color = 0x00ff00;

    if (bmi < 18.5) {
      category = 'Thi·∫øu c√¢n';
      color = 0xffa500;
    } else if (bmi < 25) {
      category = 'C√¢n n·∫∑ng b√¨nh th∆∞·ªùng';
      color = 0x00ff00;
    } else if (bmi < 30) {
      category = 'Th·ª´a c√¢n';
      color = 0xffa500;
    } else {
      category = 'B√©o ph√¨';
      color = 0xff0000;
    }

    const bmiEmbed = {
      color,
      title: 'üìè K·∫øt qu·∫£ T√≠nh BMI',
      fields: [
        { name: 'üìä BMI', value: bmi.toFixed(1), inline: true },
        { name: 'üìã Ph√¢n lo·∫°i', value: category, inline: true },
        { name: 'üìè Chi·ªÅu cao', value: `${height} cm`, inline: true },
        { name: '‚öñÔ∏è C√¢n n·∫∑ng', value: `${weight} kg`, inline: true },
      ],
      footer: {
        text: 'L∆∞u √Ω: BMI ch·ªâ l√† ch·ªâ s·ªë tham kh·∫£o. H√£y tham kh·∫£o √Ω ki·∫øn chuy√™n gia y t·∫ø ƒë·ªÉ c√≥ l·ªùi khuy√™n c√° nh√¢n h√≥a.',
      },
    };

    await message.reply({ embeds: [bmiEmbed] });

    // Save BMI as health record
    try {
      const healthRecord = this.healthRecordRepository.create({
        user,
        type: HealthRecordType.BMI,
        data: bmi.toFixed(1) as any,
        notes: `Chi·ªÅu cao: ${height}cm, C√¢n n·∫∑ng: ${weight}kg, Ph√¢n lo·∫°i: ${category}`,
        recordedAt: new Date(),
      });
      await this.healthRecordRepository.save(healthRecord);
    } catch (error) {
      this.logger.error('Error saving BMI record:', error);
    }
  }

  private async handleReminderCommand(message: Message, args: string[], user: User) {
    const subCommand = args[0]?.toLowerCase();

    switch (subCommand) {
      case 'add':
      case 'them':
        await this.addReminder(message, args.slice(1), user);
        break;
      case 'list':
      case 'danhsach':
        await this.listReminders(message, user);
        break;
      case 'delete':
      case 'xoa':
        await this.deleteReminder(message, args.slice(1), user);
        break;
      default:
        await message.reply('‚è∞ **L·ªánh Nh·∫Øc nh·ªü**\n`!reminder them <th·ªùi gian> <tin nh·∫Øn>` - Th√™m nh·∫Øc nh·ªü m·ªõi\n`!reminder danhsach` - Xem c√°c nh·∫Øc nh·ªü ƒëang ho·∫°t ƒë·ªông\n`!reminder xoa <id>` - X√≥a nh·∫Øc nh·ªü\n\nƒê·ªãnh d·∫°ng th·ªùi gian: HH:MM (24 gi·ªù) ho·∫∑c "hangngay HH:MM"');
    }
  }

  private async addReminder(message: Message, args: string[], user: User) {
    if (args.length < 2) {
      await message.reply('‚è∞ **Th√™m Nh·∫Øc nh·ªü**\nC√°ch d√πng: `!reminder them <th·ªùi gian> <ti√™u ƒë·ªÅ> [m√¥ t·∫£]`\nV√≠ d·ª•:\n`!reminder them 14:30 "U·ªëng thu·ªëc" Thu·ªëc huy·∫øt √°p h√†ng ng√†y`\n`!reminder them hangngay 08:00 "Vitamin bu·ªïi s√°ng"`');
      return;
    }

    let timeStr = args[0];
    let frequency = 'once';
    let title = '';
    let description = '';
    
    if (args[0].toLowerCase() === 'hangngay' || args[0].toLowerCase() === 'daily') {
      frequency = 'daily';
      timeStr = args[1];
      title = args.slice(2, 3).join(' ').replace(/"/g, '');
      description = args.slice(3).join(' ').replace(/"/g, '');
    } else {
      title = args.slice(1, 2).join(' ').replace(/"/g, '');
      description = args.slice(2).join(' ').replace(/"/g, '');
    }

    // Validate time format (HH:MM)
    const timeRegex = /^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/;
    if (!timeRegex.test(timeStr)) {
      await message.reply('‚ùå ƒê·ªãnh d·∫°ng th·ªùi gian kh√¥ng h·ª£p l·ªá. Vui l√≤ng s·ª≠ d·ª•ng HH:MM (ƒë·ªãnh d·∫°ng 24 gi·ªù).');
      return;
    }

    try {
      const reminder = this.reminderRepository.create({
        user,
        title,
        description,
        type: ReminderType.CUSTOM,
        frequency: frequency as any,
        reminderTime: timeStr,
        isActive: true,
      });

      await this.reminderRepository.save(reminder);
      
      const recurringText = frequency === 'daily' ? 'h√†ng ng√†y ' : 'm·ªôt l·∫ßn ';
      await message.reply(`‚úÖ **ƒê√£ ƒê·∫∑t Nh·∫Øc nh·ªü**\n‚è∞ Nh·∫Øc nh·ªü ${recurringText}l√∫c ${timeStr}\nüìù Ti√™u ƒë·ªÅ: "${title}"\nüìÑ M√¥ t·∫£: "${description || 'Kh√¥ng c√≥'}"`);
    } catch (error) {
      this.logger.error('Error saving reminder:', error);
      await message.reply('‚ùå Kh√¥ng th·ªÉ l∆∞u nh·∫Øc nh·ªü. Vui l√≤ng th·ª≠ l·∫°i.');
    }
  }

  private async listReminders(message: Message, user: User) {
    try {
      const reminders = await this.reminderRepository.find({
        where: { user: { id: user.id }, isActive: true },
        order: { reminderTime: 'ASC' },
      });

      if (reminders.length === 0) {
        await message.reply('‚è∞ **Nh·∫Øc nh·ªü c·ªßa B·∫°n**\nKh√¥ng t√¨m th·∫•y nh·∫Øc nh·ªü n√†o ƒëang ho·∫°t ƒë·ªông. Th√™m m·ªôt c√°i v·ªõi `!reminder them`');
        return;
      }

      const reminderEmbed = {
        color: 0xffa500,
        title: '‚è∞ Nh·∫Øc nh·ªü ƒêang ho·∫°t ƒë·ªông c·ªßa B·∫°n',
        fields: reminders.map((reminder) => ({
          name: `${reminder.id}. ${reminder.frequency === 'daily' ? 'H√†ng ng√†y' : 'M·ªôt l·∫ßn'} - ${reminder.reminderTime}`,
          value: `üìù ${reminder.title}\nüìÑ ${reminder.description || 'Kh√¥ng c√≥ m√¥ t·∫£'}`,
          inline: false,
        })),
        footer: {
          text: 'S·ª≠ d·ª•ng !reminder xoa <id> ƒë·ªÉ x√≥a nh·∫Øc nh·ªü',
        },
      };

      await message.reply({ embeds: [reminderEmbed] });
    } catch (error) {
      this.logger.error('Error fetching reminders:', error);
      await message.reply('‚ùå Kh√¥ng th·ªÉ l·∫•y danh s√°ch nh·∫Øc nh·ªü. Vui l√≤ng th·ª≠ l·∫°i.');
    }
  }

  private async deleteReminder(message: Message, args: string[], user: User) {
    if (args.length === 0) {
      await message.reply('‚ùå Vui l√≤ng cung c·∫•p ID nh·∫Øc nh·ªü. S·ª≠ d·ª•ng `!reminder danhsach` ƒë·ªÉ xem c√°c ID.');
      return;
    }

    const reminderId = parseInt(args[0]);
    if (isNaN(reminderId)) {
      await message.reply('‚ùå Vui l√≤ng cung c·∫•p ID nh·∫Øc nh·ªü h·ª£p l·ªá (s·ªë).');
      return;
    }

    try {
      const reminder = await this.reminderRepository.findOne({
        where: { id: reminderId, user: { id: user.id } },
      });

      if (!reminder) {
        await message.reply('‚ùå Kh√¥ng t√¨m th·∫•y nh·∫Øc nh·ªü ho·∫∑c b·∫°n kh√¥ng c√≥ quy·ªÅn x√≥a n√≥.');
        return;
      }

      await this.reminderRepository.remove(reminder);
      await message.reply(`‚úÖ **ƒê√£ X√≥a Nh·∫Øc nh·ªü**\nƒê√£ x√≥a nh·∫Øc nh·ªü: "${reminder.title}" l√∫c ${reminder.reminderTime}`);
    } catch (error) {
      this.logger.error('Error deleting reminder:', error);
      await message.reply('‚ùå Kh√¥ng th·ªÉ x√≥a nh·∫Øc nh·ªü. Vui l√≤ng th·ª≠ l·∫°i.');
    }
  }

  private async handleEmergencyCommand(message: Message, args: string[], user: User) {
    const subCommand = args[0]?.toLowerCase();

    switch (subCommand) {
      case 'add':
      case 'them':
        await this.addEmergencyContact(message, args.slice(1), user);
        break;
      case 'list':
      case 'danhsach':
        await this.listEmergencyContacts(message, user);
        break;
      case 'call':
      case 'goi':
        await this.showEmergencyNumbers(message);
        break;
      default:
        await message.reply('üö® **L·ªánh Kh·∫©n c·∫•p**\n`!emergency them <t√™n> <sƒët> <m·ªëi quan h·ªá>` - Th√™m li√™n h·ªá kh·∫©n c·∫•p\n`!emergency danhsach` - Xem li√™n h·ªá kh·∫©n c·∫•p\n`!emergency goi` - Hi·ªÉn th·ªã s·ªë ƒëi·ªán tho·∫°i kh·∫©n c·∫•p');
    }
  }

  private async addEmergencyContact(message: Message, args: string[], user: User) {
    if (args.length < 3) {
      await message.reply('üö® **Th√™m Li√™n h·ªá Kh·∫©n c·∫•p**\nC√°ch d√πng: `!emergency them <t√™n> <sƒët> <m·ªëi quan h·ªá>`\nV√≠ d·ª•: `!emergency them "B√°c sƒ© Nguy·ªÖn" +84123456789 "B√°c sƒ© gia ƒë√¨nh"`');
      return;
    }

    const name = args[0].replace(/"/g, '');
    const phone = args[1];
    const relation = args.slice(2).join(' ').replace(/"/g, '');

    try {
      const contact = this.emergencyContactRepository.create({
        user: user,
        name,
        phoneNumber: phone,
        relationship: relation,
      });

      await this.emergencyContactRepository.save(contact);
      await message.reply(`‚úÖ **ƒê√£ Th√™m Li√™n h·ªá Kh·∫©n c·∫•p**\nüë§ T√™n: ${name}\nüìû S·ªë ƒëi·ªán tho·∫°i: ${phone}\nüè∑Ô∏è M·ªëi quan h·ªá: ${relation}`);
    } catch (error) {
      this.logger.error('Error saving emergency contact:', error);
      await message.reply('‚ùå Kh√¥ng th·ªÉ l∆∞u li√™n h·ªá kh·∫©n c·∫•p. Vui l√≤ng th·ª≠ l·∫°i.');
    }
  }

  private async listEmergencyContacts(message: Message, user: User) {
    try {
      const contacts = await this.emergencyContactRepository.find({
        where: { user: { id: user.id } },
        order: { name: 'ASC' },
      });

      if (contacts.length === 0) {
        await message.reply('üö® **Li√™n h·ªá Kh·∫©n c·∫•p**\nKh√¥ng t√¨m th·∫•y li√™n h·ªá kh·∫©n c·∫•p n√†o. Th√™m m·ªôt c√°i v·ªõi `!emergency them`');
        return;
      }

      const contactEmbed = {
        color: 0xff0000,
        title: 'üö® Li√™n h·ªá Kh·∫©n c·∫•p c·ªßa B·∫°n',
        fields: contacts.map((contact) => ({
          name: `üë§ ${contact.name}`,
          value: `üìû ${contact.phoneNumber}\nüè∑Ô∏è ${contact.relationship}`,
          inline: true,
        })),
        footer: {
          text: 'H√£y gi·ªØ nh·ªØng li√™n h·ªá n√†y lu√¥n ƒë∆∞·ª£c c·∫≠p nh·∫≠t v√† d·ªÖ ti·∫øp c·∫≠n',
        },
      };

      await message.reply({ embeds: [contactEmbed] });
    } catch (error) {
      this.logger.error('Error fetching emergency contacts:', error);
      await message.reply('‚ùå Kh√¥ng th·ªÉ l·∫•y danh s√°ch li√™n h·ªá kh·∫©n c·∫•p. Vui l√≤ng th·ª≠ l·∫°i.');
    }
  }

  private async showEmergencyNumbers(message: Message) {
    const emergencyEmbed = {
      color: 0xff0000,
      title: 'üö® S·ªë ƒëi·ªán tho·∫°i Kh·∫©n c·∫•p',
      fields: [
        { name: 'üöë C·∫•p c·ª©u (Vi·ªát Nam)', value: '115', inline: true },
        { name: 'üöì C√¥ng an (Vi·ªát Nam)', value: '113', inline: true },
        { name: 'üöí C·ª©u h·ªèa (Vi·ªát Nam)', value: '114', inline: true },
        { name: '‚òéÔ∏è T·ªïng ƒë√†i c·∫•p c·ª©u 24/7', value: '19009095', inline: true },
        { name: 'üß† ƒê∆∞·ªùng d√¢y n√≥ng t√¢m l√Ω', value: '18001567', inline: true },
        { name: 'üìû T∆∞ v·∫•n s·ª©c kh·ªèe', value: '19003888', inline: true },
      ],
      footer: {
        text: 'Trong tr∆∞·ªùng h·ª£p kh·∫©n c·∫•p, h√£y lu√¥n g·ªçi s·ªë c·∫•p c·ª©u ƒë·ªãa ph∆∞∆°ng tr∆∞·ªõc',
      },
    };

    await message.reply({ embeds: [emergencyEmbed] });
  }

  private async handleStatsCommand(message: Message, user: User) {
    try {
      const userWithRelations = await this.userRepository.findOne({
        where: { id: user.id },
        relations: ['healthRecords', 'reminders', 'emergencyContacts'],
      });

      if (!userWithRelations) {
        await message.reply('‚ùå Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng. Vui l√≤ng th·ª≠ l·∫°i.');
        return;
      }

      const activeReminders = userWithRelations.reminders?.filter(r => r.isActive) || [];

      const statsEmbed = {
        color: 0x0099ff,
        title: 'üìä Th·ªëng k√™ Bot S·ª©c kh·ªèe c·ªßa B·∫°n',
        fields: [
          { name: 'üìà D·ªØ li·ªáu S·ª©c kh·ªèe', value: (userWithRelations.healthRecords?.length || 0).toString(), inline: true },
          { name: '‚è∞ Nh·∫Øc nh·ªü ƒêang ho·∫°t ƒë·ªông', value: activeReminders.length.toString(), inline: true },
          { name: 'üö® Li√™n h·ªá Kh·∫©n c·∫•p', value: (userWithRelations.emergencyContacts?.length || 0).toString(), inline: true },
          { name: 'üìÖ Th√†nh vi√™n t·ª´', value: new Date(userWithRelations.createdAt).toLocaleDateString('vi-VN'), inline: false },
        ],
        timestamp: new Date().toISOString(),
      };

      await message.reply({ embeds: [statsEmbed] });
    } catch (error) {
      this.logger.error('Error fetching user stats:', error);
      await message.reply('‚ùå Kh√¥ng th·ªÉ l·∫•y th·ªëng k√™. Vui l√≤ng th·ª≠ l·∫°i.');
    }
  }

  private async sendHelpMessage(message: Message) {
    const helpEmbed = {
      color: 0x0099ff,
      title: 'üè• L·ªánh Bot ChƒÉm s√≥c S·ª©c kh·ªèe',
      description: 'Tr·ª£ l√Ω s·ª©c kh·ªèe c√° nh√¢n c·ªßa b·∫°n tr√™n Discord!',
      fields: [
        {
          name: 'üèì L·ªánh C∆° b·∫£n',
          value: '`!ping` - Ki·ªÉm tra tr·∫°ng th√°i bot\n`!help` ho·∫∑c `!trogiup` - Hi·ªÉn th·ªã tin nh·∫Øn tr·ª£ gi√∫p n√†y\n`!stats` ho·∫∑c `!thongke` - Xem th·ªëng k√™ c·ªßa b·∫°n',
          inline: false,
        },
        {
          name: 'üè• L·ªánh S·ª©c kh·ªèe',
          value: '`!health ghi <lo·∫°i> <gi√° tr·ªã> [ghi ch√∫]` - Ghi d·ªØ li·ªáu s·ª©c kh·ªèe\n`!health lichsu` - Xem l·ªãch s·ª≠ s·ª©c kh·ªèe\n`!health bmi <chi·ªÅu cao> <c√¢n n·∫∑ng>` - T√≠nh BMI',
          inline: false,
        },
        {
          name: '‚è∞ L·ªánh Nh·∫Øc nh·ªü',
          value: '`!reminder them <th·ªùi gian> <tin nh·∫Øn>` - Th√™m nh·∫Øc nh·ªü\n`!reminder danhsach` - Xem nh·∫Øc nh·ªü ƒëang ho·∫°t ƒë·ªông\n`!reminder xoa <id>` - X√≥a nh·∫Øc nh·ªü',
          inline: false,
        },
        {
          name: 'üö® L·ªánh Kh·∫©n c·∫•p',
          value: '`!emergency them <t√™n> <sƒët> <m·ªëi quan h·ªá>` - Th√™m li√™n h·ªá\n`!emergency danhsach` - Xem li√™n h·ªá\n`!emergency goi` - Hi·ªÉn th·ªã s·ªë kh·∫©n c·∫•p',
          inline: false,
        },
        {
          name: 'ü§ñ Tr√≤ chuy·ªán AI',
          value: 'Mention t√¥i (@HealthBot) ho·∫∑c nh·∫Øn tin ri√™ng ƒë·ªÉ tr√≤ chuy·ªán t·ª± nhi√™n v·ªÅ c√°c ch·ªß ƒë·ªÅ s·ª©c kh·ªèe!',
          inline: false,
        },
      ],
      footer: {
        text: 'Lu√¥n tham kh·∫£o √Ω ki·∫øn chuy√™n gia y t·∫ø cho nh·ªØng v·∫•n ƒë·ªÅ s·ª©c kh·ªèe nghi√™m tr·ªçng',
      },
      timestamp: new Date().toISOString(),
    };

    await message.reply({ embeds: [helpEmbed] });
  }
}
